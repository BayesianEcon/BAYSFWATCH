---
title: "BAYSFWATCH: An R Package for Outlier Detection with Matrix-variate Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BAYSFWATCH: An R Package for Outlier Detection with Matrix-variate Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  fig.align = "right",     # aligns logo right
  out.width = "120px"      # adjust logo size
)
options(width = 80)
```

<img src="logo.png" width="130" align="left" />

```{r echo=TRUE, fig.width=8, fig.height=3, out.width="100%", results='hide'}
library(BAYSFWATCH)

#Generate a Synthetic Dataset or use your own data
#A set of outliers have been injected in Ts p x n matrices
#outv allows to pick a value for the value to the outliers
#outc is  an integer (1 to 4) defining the type of outlier injection:
#   - 1: Adds `outv` to all values in the matrix.
#   - 2: Adds `outv` to a single element (1,1) in the matrix.
#   - 3: Adds `outv` to `outn` randomly chosen elements in the matrix.
#   - 4: Adds `outv` to `Rcn` columns and `Rrn` rows, randomly selected.
# outn is the number of outliers to inject (only used in options 3 and 4).
#Must be lower than `pxn`.
#see the documentation to set the other parameters
?GenData

Data<-GenData(outv = 5, outc = 3, outn = 6, Rcn = 3, Rrn = 2)

set.seed(42)
matrix1 <- Data$X3D[,,79]
matrix2 <- Data$X3D[,,80]
matrix3 <- Data$X3D[,,81]

# Define the common color scale
zlim <- range(c(matrix1, matrix2, matrix3))


# Plot the three matrices
par(mfrow = c(1, 3),    # 1 row, 3 columns
    mar = c(2, 2, 3, 2), # margins: bottom, left, top, right
    oma = c(0, 0, 2, 0), # outer margins (optional)
    asp = 1,   # square aspect
    xaxs = "i", yaxs = "i")# force square aspect ratio

# Use blue or green scale (e.g., topographical blues)
blue_col <- colorRampPalette(c("white", "lightblue", "blue"))(100)

# Plot
image(matrix1, col = blue_col, main = "Matrix 79", zlim = zlim)
image(matrix2, col = blue_col, main = "Matrix 80", zlim = zlim) #outliers
image(matrix3, col = blue_col, main = "Matrix 81", zlim = zlim)
```

```{r, results='hide', fig.width=8, fig.height=3, out.width="100%"}
#Example 1: Outlier Detection 
#see the documentation to set the other parameters
?OutlierDetection

results <- OutlierDetection(Data$X3D,  M = Data$M, Sl = Data$Sl, V =  Data$V)

```

```{r, results='hide', fig.width=8, fig.height=3, out.width="100%"}
#Example 2: Outlier Detection with MLE and one single outlier
#Generate the Data with one single outlier in position (1,1) to matrix 80.
Data<-GenData(outv = 2, outc = 2, outn = 6, Rcn = 3, Rrn = 2)

#If M, Sl and V are not specified,
#the algorithm automatically computes matrices recursively via MLE.

results <- OutlierDetection(Data$X3D)
```


```{r, results='hide', fig.width=8, fig.height=3, out.width="100%"}
#Example 3: When the magnitude of the outlier is small,
#Note that when we introduce one single outlier with moderate absolute value, 
#the uncertainty about the nature of the outlier is higher.

Data<-GenData(outv = 1, outc = 2, outn = 6, Rcn = 3, Rrn = 2)
results <- OutlierDetection(Data$X3D)
```
